module add_particles
    use curand_device
    use mrand, only: h
contains
attributes(global) subroutine add_init_particles( &
    P,C,Saturation,Porosity,np_ic,nind,denh2o,outkk, &
    nnx1,nny1,nz,ix1,iy1,dx,dy,dz)

    implicit none
    real(8),intent(inout):: P(:,:), C(:,:,:,:)
    real(8),intent(in):: Saturation(:,:,:), Porosity(:,:,:), dz(:)
    integer,value:: np_ic, nind
    integer,value:: outkk, nnx1, nny1, nz, ix1, iy1
    real(8),value:: dx, dy, denh2o
    integer:: i, j, k, index, ij, ik, ii, Ploc(3)
    real(8):: Z

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    ! get i, j, k from ii
    if(ii <= nnx1*nny1*nz) then
        if(mod(ii,nnx1*nny1) == 0) then
            k = ii/(nnx1*nny1)
            j = nny1
            i = nnx1
        else
            k = ii/(nnx1*nny1) + 1
            if(mod(mod(ii,nnx1*nny1),nnx1) == 0) then
                j = nny1
                i = nnx1
            else
                j = mod(ii,nnx1*nny1)/nnx1 + 1
                i = mod(mod(ii,nnx1*nny1),nnx1)
            end if
        end if

        if(Saturation(i,j,k) > 0.d0) then
            do ij = 1, np_ic

                index = ii*np_ic - (ij - 1)

                P(index,1) = float(i-1+ix1)*dx + curand_uniform(h(ii))*dx ! should use global
                P(index,2) = float(j-1+iy1)*dy + curand_uniform(h(ii))*dy ! update that for random number
                P(index,13+2*nind) = float(index)
                P(index,14+2*nind) = P(index,1)
                P(index,15+2*nind) = P(index,2)
                P(index,17+2*nind) = outkk

                Z = 0.0d0
                do ik = 1, nz
                    Z = Z + dz(ik)
                end do
                P(index,3) = Z - dz(k)*curand_uniform(h(ii))
                P(index,16+2*nind) = P(index,3)

                P(index,6) = dx*dy*dz(k)*(Porosity(i,j,k) &
                             *Saturation(i,j,k))*denh2o*(1.0d0/float(np_ic))
                P(index,7) = 1.0d0
                P(index,8) = 1.0d0  ! make particle active

                C(1,i,j,k) = 0.d0
                C(1,i,j,k) = C(1,i,j,k) + P(index,8)*P(index,6) / &
                (dx*dy*dz(k)*(Porosity(i,j,k)*Saturation(i,j,k)))

                C(2,i,j,k) = 0.d0
                C(2,i,j,k) = C(2,i,j,k) + P(index,8)*P(index,4)*P(index,6)

                C(4,i,j,k) = 0.d0
                C(4,i,j,k) = C(4,i,j,k) + P(index,8)*P(index,7)*P(index,6)

                C(3,i,j,k) = 0.d0
                C(3,i,j,k) = C(3,i,j,k) + P(index,8)*P(index,6)

            enddo
        endif
    end if
end subroutine add_init_particles

attributes(global) subroutine river_init_particles( &
    P,C,Saturation,Porosity,np_ic,np_active,pid,nind, &
    nnx1,nny1,nz,ix1,iy1,dx,dy,dz,pfdt,denh2o,outkk)

    implicit none
    real(8),intent(inout):: P(:,:), C(:,:,:,:)
    real(8),intent(in):: Saturation(:,:,:), Porosity(:,:,:), dz(:)
    integer,value:: np_ic, np_active, nind
    integer,value:: outkk, nnx1, nny1, nz, ix1, iy1
    real(8),value:: dx, dy, pfdt, denh2o
    integer:: i, j, k, index, ij, ik, ii, itemp, Ploc(3)
    real(8):: Z

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    if(ii <= nnx1*nny1) then

        if(mod(ii,nnx1) == 0) then
            j = ii/nnx1
            i = nnx1
        else
            j = ii/nnx1 + 1
            i = mod(ii,nnx1)
        end if
        k = nz

        do ij = 1, abs(np_ic)

            index = ii*abs(np_ic) - (ij - 1)

            P(index,13+2*nind) = float(index)
            ! this is no use anymore and reserved for particle transfer
            P(index,1) = float(i+ix1-1)*dx + curand_uniform(h(index))*dx
            P(index,2) = float(j+iy1-1)*dy + curand_uniform(h(index))*dy
            P(index,14+2*nind) = P(index,1) ! Saving the initial location
            P(index,15+2*nind) = P(index,2)
            P(index,17+2*nind) = outkk + 0.0 !setting insert time to the start time

            Z = 0.0d0
            do ik = 1, k
                Z = Z + dz(ik)
            end do

            P(index,3) = Z !-dz(k)*ran1(ir)
            P(index,16+2*nind) = P(index,3)
            P(index,6) = dx*dy*dz(k)*(Porosity(i,j,k)*Saturation(i,j,k)) &
                         *denh2o*(1.0d0/float(np_ic))
            P(index,7) = 1.0d0
            P(index,8) = 1.0d0
            ! set up intial concentrations
            C(1,i,j,k) = C(1,i,j,k) + P(index,8)*P(index,6) / &
                         (dx*dy*dz(k)*(Porosity(i,j,k)*Saturation(i,j,k)))
            C(2,i,j,k) = C(2,i,j,k) + P(index,8)*P(index,4)*P(index,6)
            C(4,i,j,k) = C(4,i,j,k) + P(index,8)*P(index,7)*P(index,6)
            C(3,i,j,k) = C(3,i,j,k) + P(index,8)*P(index,6)
        end do

    end if

end subroutine river_init_particles

attributes(global) subroutine scan_new_particles( &
    EvapTrans,PET_balance,d_isValid,nnx1,nny1,nz,dx,dy,dz, &
    pfdt,denh2o)

    implicit none
    real(8),intent(in)::EvapTrans(:,:,:)
    real(8),intent(out)::PET_balance(:)
    integer,intent(out)::d_isValid(:)
    integer,value:: nnx1, nny1, nz
    real(8),value:: dx,dy,dz,pfdt,denh2o
    integer:: i, j, k, ii
    real(8):: temp

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    ! get i, j, k from ii
    if(ii <= nnx1*nny1*nz) then
        if(mod(ii,nnx1*nny1) == 0) then
            k = ii/(nnx1*nny1)
            j = nny1
            i = nnx1
        else
            k = ii/(nnx1*nny1) + 1
            if(mod(mod(ii,nnx1*nny1),nnx1) == 0) then
                j = mod(ii,nnx1*nny1)/nnx1
                i = nnx1
            else
                j = mod(ii,nnx1*nny1)/nnx1 + 1
                i = mod(mod(ii,nnx1*nny1),nnx1)
            end if
        end if


        if(EvapTrans(i,j,k) > 0.d0) then
            temp = atomicAdd(PET_balance(1),pfdt*EvapTrans(i,j,k)*dx*dy*dz(k)*denh2o)
            if(k == nz) d_isValid(ii - nnx1*nny1*(nz-1)) = 1
            ! only the top layer (k = nz) will introduce new particles
        else
            temp = atomicAdd(PET_balance(2),pfdt*EvapTrans(i,j,k)*dx*dy*dz(k)*denh2o)
            if(k == nz) d_isValid(ii - nnx1*nny1*(nz-1)) = 0
        endif
    end if !!! parobably need move to the end of the subroutine
end subroutine scan_new_particles

attributes(global) subroutine add_new_particles( &
    d_indices,P,EvapTrans,CLMvars,Ind,iflux_p_res,np_active,pid, &
    nind,nnx1,nny1,nz,ix1,iy1,dx,dy,dz,pfdt,denh2o,kk,outkk)
    ! CLMvars is only CLMvars(i,j,11)

    implicit none
    real(8),intent(inout):: P(:,:)
    real(8),intent(in):: EvapTrans(:,:,:), CLMvars(:,:), Ind(:,:,:), dz(:)
    integer,intent(in):: d_indices(:)
    integer,value:: iflux_p_res, np_active, nind
    integer,value:: kk, outkk, nnx1, nny1, nz
    real(8),value:: dx, dy, pfdt, denh2o
    integer:: i, j, k, index, ij, ik, ii, itemp, Ploc(3)
    real(8):: Z

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    if(ii <= nnx1*nny1) then
        ! get i, j from ii
        if(mod(ii,nnx1) == 0) then
            j = ii/nnx1
            i = nnx1
        else
            j = ii/nnx1 + 1
            i = mod(ii,nnx1)
        end if
        k = nz

        if(EvapTrans(i,j,nz) > 0.d0) then
            do ij = 1, iflux_p_res

                index = np_active + d_indices(ii)*iflux_p_res - (ij - 1)

                P(index,1) = float(i-1)*dx + curand_uniform(h(index))*dx
                P(index,2) = float(j-1)*dy + curand_uniform(h(index))*dy ! update that for random number
                P(index,13+2*nind) = float(pid + d_indices(ii)*iflux_p_res - (ij - 1))
                P(index,14+2*nind) = P(index,1)
                P(index,15+2*nind) = P(index,2)

                !Z = 0.0d0
                !do ik = 1, nz
                !    Z = Z + dz(ik)
                !end do
                P(index,3) = sum(dz) - dz(nz)*0.5d0
                P(index,16+2*nind) = P(index,3)

                P(index,4) = 0.0d0 + curand_uniform(h(index))*pfdt

                if (nind > 0) then
                    Ploc(1) = floor(P(index,1) / dx)
                    Ploc(2) = floor(P(index,2) / dy)
                    Ploc(3) = nz-1

                    itemp=idnint(Ind(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
                    if(itemp > 0 .and. itemp <= nind) then
                    P(index,(12+itemp)) = P(index,(12+itemp)) + P(index,4)
                    end if
                end if

                P(index,5) = 0.0d0
                P(index,17+2*nind) = outkk + float((kk-1))*pfdt + P(index,4)
                P(index,6) = (1.0d0/float(abs(iflux_p_res)))*pfdt* &
                            EvapTrans(i,j,nz)*dx*dy*dz(k)*denh2o

                if(CLMvars(i,j) > 0.d0) then !this is snowmelt
                    P(index,7) = 3.d0 ! Snow composition
                else
                    P(index,7) = 2.d0 ! Rainfall composition
                end if

                P(index,8)  = 1.0d0  ! make particle active
                P(index,9)  = 1.0d0
                P(index,10) = 0.0d0  ! Particle hasn't exited domain
            enddo
        endif
    endif
end subroutine add_new_particles

end module add_particles