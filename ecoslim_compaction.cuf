module compact_array
    ! 1 attributes(global) subroutine compaction_copy
    ! 2 attributes(global) subroutine prepare_holes
    ! 3 attributes(global) subroutine compaction_inplace
    ! 4 attributes(global) subroutine prepare_neighbor
    ! 5 attributes(global) subroutine prepare_exit
    ! 6 attributes(global) subroutine connect_recv
    ! 7 attributes(global) subroutine scan_zone


contains
!1--------------------------------------------------------------------
    attributes(global) subroutine compaction_copy(d_out,d_indices,d_isValid,&
                                                  d_in,numElements,n_attri)
    !For particle transfer between neighbours
    !The first dimension of d_in equals that of d_indices and d_isValid
    !This dimension is the current np_active
    !d_indices is the inclusive Sum-Scan Result which is different from C/C++
    !original:     1 0 1 1 0 0 1 0  (d_isValid)
    !index(or ii): 1 2 3 4 5 6 7 8
    !prefix sum:   1 1 2 3 3 3 4 4  (inclusive d_indices)
    !numElements:  8 (np_active)
    !Dimension of d_out can be determined by prefix sum, such as d_indices(np_active) = 4
    !Coalesced access to global memory or not is determined by ???

    implicit none
    real(8),intent(out):: d_out(:,:)
    real(8),intent(in):: d_in(:,:)
    real(8),intent(in):: d_indices(:), d_isValid(:)
    integer,value::numElements, n_attri
    integer:: ii, j   !global index in the array

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    if(ii <= numElements .and. idnint(d_isValid(ii)) > 0) then
        do j = 1, n_attri
            d_out(idnint(d_indices(ii)),j) = d_in(ii,j)
        enddo
    end if

    end subroutine compaction_copy
!2--------------------------------------------------------------------
    attributes(global) subroutine prepare_holes(holes,d_indices,d_isValid,&
                                                numElements)
    !original:        1 0 1 1 0 0 1 0  d_isValid
    !index(or ii):    1 2 3 4 5 6 7 8  ii
    !prefix sum:      1 1 2 3 3 3 4 4  d_indices
    !ii-d_indices:    0 1 1 1 2 3 3 4
    !N-sum(index):    3 3 2 1 1 1 0 0  d_indices(numElements)-d_indices
    !N-sum(index)+1:  4 4 3 2 2 2 1 1  ii2
    !numElements:     8
    !holes:           2 5 6 8
    !holes index:     1 2 3 4

    implicit none
    integer,intent(in):: d_indices(:), d_isValid(:)
    integer,intent(out):: holes(:)
    !dimension is determined by np_active - d_indices(np_active)
    !np_active is numElements
    !holes is a temporary array that just needs dynamic allocation on cpu
    integer:: ii   !global index in the array
    integer,value:: numElements

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x
    if(ii <= numElements .and. d_isValid(ii) == 0) then
        holes(ii - d_indices(ii)) = ii
    end if

    end subroutine prepare_holes
!3--------------------------------------------------------------------
    attributes(global) subroutine compaction_inplace(holes,d_indices,d_isValid,&
                                                     d_in,d_out,numElements,n_attri)
    !original:        1 0 1 1 0 0 1 0  d_isValid
    !index(or ii):    1 2 3 4 5 6 7 8  ii
    !prefix sum:      1 1 2 3 3 3 4 4  d_indices
    !ii-d_indices:    0 1 1 1 2 3 3 4
    !N-sum(index):    3 3 2 1 1 1 0 0  d_indices(numElements)-d_indices
    !N-sum(index)+1:  4 4 3 2 2 2 1 1  ii2
    !numElements:     8
    !holes:           2 5 6 8
    !holes index:     1 2 3 4

    implicit none
    real(8),intent(inout):: d_in(:,:)
    real(8),intent(out):: d_out(:,:)
    integer,intent(in):: holes(:),d_indices(:),d_isValid(:)
    !dimension is determined by np_active - d_indices(np_active)
    !np_active is numElements
    !holes is a temporary array that just needs dynamic allocation on cpu
    integer:: ii, ii2, j   !global index in the array
    integer,value:: numElements, n_attri

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    if(ii <= numElements) &
    ii2 = d_indices(numElements) - d_indices(ii) + 1

    if(ii <= numElements .and. d_isValid(ii) == 0) then
        do j = 1, n_attri
            d_out(ii-d_indices(ii),j) = d_in(ii,j)
        enddo
    end if

    if(ii <= numElements .and. d_isValid(ii) > 0 .and. &
       holes(ii2) <= d_indices(numElements)) then
        do j = 1, n_attri
            d_in(holes(ii2),j) = d_in(ii,j)
        enddo
    end if

    end subroutine compaction_inplace
!4--------------------------------------------------------------------
    attributes(global) subroutine prepare_neighbor(d_in,d_isValid,&
                                                   numElements,neighbor)
    !numElements is the current number of elements left in P, i.e., updated np_active

    implicit none
    real(8),intent(in):: d_in(:)
    ! the 8th attribution of P array
    integer,intent(out):: d_isValid(:)
    integer,value:: numElements, neighbor
    ! numElements is the length to scan
    ! neighbor is the rank of neighbor
    integer:: ii   !global index in the array

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    if(ii <= numElements) then
        if(idnint(d_in(ii)) == neighbor+10) then
            d_isValid(ii) = 0
        else
            d_isValid(ii) = 1
        end if
    end if

    end subroutine prepare_neighbor
!5--------------------------------------------------------------------
    attributes(global) subroutine prepare_exit(d_in,d_isValid,numElements)
    implicit none
    real(8),intent(in):: d_in(:)
    integer,intent(out):: d_isValid(:)
    integer,value:: numElements
    integer:: ii   !global index in the array

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    if(ii <= numElements) then
        if(idnint(d_in(ii)) == 0) then
            d_isValid(ii) = 0
        else
            d_isValid(ii) = 1
        end if
    end if

    end subroutine prepare_exit
!6--------------------------------------------------------------------
    attributes(global) subroutine connect_recv(d_in,d_recv,&
                                        numElements,N_recv,n_attri)
    ! connect the received particles to the bottom of P and
    ! update P(:,8) of the received particles

    implicit none
    real(8),intent(in):: d_recv(:)
    real(8),intent(inout):: d_in(:)
    integer,value:: numElements, N_recv, n_attri
    integer:: ii,j   !global index in the array

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

    if(ii <= N_recv) then
        d_recv(ii,8) = 1.d0
        do j = 1, n_attri
            d_in(ii+numElements,j) = d_recv(ii,j)
        end do
    end if

    end subroutine connect_recv
!7--------------------------------------------------------------------
    attributes(global) subroutine scan_zone(zone,nnx1,nny1,buff, &
                                            d_isValid,rank,t_rank)

    implicit none
    integer,intent(in):: zone(:,:)
    integer,intent(out):: d_isValid(:)
    integer,value:: nnx1,nny1,buff,rank,t_rank
    integer:: ii,i,j,temp,lock,length

        ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        lock = 1
        length = (nnx1+2*buff)*(nny1+2*buff)
        ! this is the total length of zone array when it was transformed to 1D

        if(ii <= length) then
            if(mod(ii, nnx1 + 2*buff) == 0) then
                j = ii/(nnx1 + 2*buff) - buff
                i = nnx1 + buff
            else
                j = ii/(nnx1 + 2*buff) - buff + 1
                i = mod(ii,nnx1 + 2*buff) - buff
            end if
        end if

        if(ii <= t_rank) d_isValid(ii) = 0
        ! for this scan, we only have t_rank elements

        if(ii <= length) then
            if(zone(i,j) >= 0 .and. zone(i,j) /= rank) then
                temp = atomicAdd(d_isValid(zone(i,j)+1),lock)
            end if
        end if

        if(ii <= t_rank .and. d_isValid(ii) > 0) d_isValid(ii) = 1

    end subroutine scan_zone

end module compact_array