module particle_loop
    use mrand, only: h
contains
 attributes(global) subroutine particles_independent( &
 P,C,dz,EvapTrans,Vx,Vy,Vz,Saturation,Porosity,Ind,Zone, &
 out_age,out_mass,out_comp,et_age,et_mass,et_comp,out_np,et_np, &
 kk,np_active,nz,nind,pfdt,moldiff,dx,dy,denh2o,dtfrac, &
 ix1,iy1,buff,reflect,nnx1,nny1,rank, &
 xgmin,ygmin,zgmin,xgmax,ygmax,zgmax,xmin,ymin,zmin,xmax,ymax,zmax)
 ! zmin and zmax are the same to zgmin and zgmax
 ! xmin,ymin,xmax,ymax are those with buffer Zone

  implicit none

  ! integer,parameter::tPB = 256
  real(8),intent(inout)::P(:,:),C(:,:,:,:)
  real(8),intent(in)::dz(:),EvapTrans(:,:,:),Vx(:,:,:),Vy(:,:,:),Vz(:,:,:)
  real(8),intent(in)::Saturation(:,:,:),Porosity(:,:,:),Ind(:,:,:)
  integer,intent(in)::Zone(:,:)

  integer,value::kk,np_active,nz,nind,ix1,iy1,buff,nnx1,nny1,rank
  real(8),value::pfdt,moldiff,dx,dy,denh2o,dtfrac
  real(8),value::xmin,ymin,zmin,xmax,ymax,zmax
  real(8),value::xgmin,ygmin,zgmin,xgmax,ygmax,zgmax
  logical,value::reflect

  integer::ii,k,Ploc(3),ir,itemp
  real(8)::Clocx,Clocy,Clocz,Vpx,Z,Vpy,Vpz, &
  particledt,delta_time,et_flux,water_vol,advdt(3), &
  z1,z2,z3,Zr,temp,lock,Ltemp

  ! global
  real(8),intent(inout)::out_age(:),out_mass(:),out_comp(:), &
                         et_age(:),et_mass(:),et_comp(:)
  integer,intent(inout)::out_np(:),et_np(:)

!--------------------------------------
    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x
    lock = 1.d0
!--------------------------------------
    ! Transfer global to local
    P(ii,1) = P(ii,1) - ix1*dx
    P(ii,2) = P(ii,2) - iy1*dy

!--------------------------------------
    delta_time = 0.d0

    if(P(ii,8) == 1. .and. ii <= np_active) then

        delta_time = P(ii,4) + pfdt

        do while (P(ii,4) < delta_time)

            ! Find the "adjacent" cell corresponding to the particle's location
            ! FLOOR(A) returns the greatest integer less than or equal to X.
            Ploc(1) = floor(P(ii,1) / dx)
            Ploc(2) = floor(P(ii,2) / dy)
            ! The right side is not included. Hence if a particle is on the right
            ! boundary, there will be problem. Particularly, after the decomposition.
            if(Ploc(1) >= nnx1 + buff) Ploc(1) = nnx1 + buff - 1
            if(Ploc(2) >= nny1 + buff) Ploc(2) = nny1 + buff - 1

            Z = 0.d0
            do k = 1, nz
                Z = Z + dz(k)
                if (Z >= P(ii,3)) then
                    Ploc(3) = k - 1
                    exit
                end if
            end do
            ! The upper is inculded, no over-bound problem.

            ! check to make sure particles are in central part of the domain and if not
            ! apply some boundary condition to them
            ! check if particles are in domain, need to expand this to include better treatment of BC's
            if ((P(ii,1) < Xmin).or.(P(ii,2) < Ymin).or.(P(ii,3) < Zmin).or. &
                (P(ii,1) >= Xmax).or.(P(ii,2) >= Ymax).or.(P(ii,3) >= (Zmax-dz(nz)))) then

            if ((P(ii,3) >= Zmax-(dz(nz)*0.5d0)).and. &
                (Saturation(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) == 1.).and. &
                (Vz(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) > 0.d0)) then

                temp = atomicAdd(Out_age(1), P(ii,4)*P(ii,6))
                temp = atomicAdd(Out_mass(1), P(ii,6))

                if (P(ii,7) == 1.) then
                temp = atomicAdd(Out_comp(1), P(ii,6))
                end if

                if (P(ii,7) == 2.) then
                temp = atomicAdd(Out_comp(2), P(ii,6))
                end if

                if (P(ii,7) == 3.) then
                temp = atomicAdd(Out_comp(3), P(ii,6))
                end if

                temp = atomicAdd(Out_np(1), idnint(lock))

                ! flag particle as inactive
                P(ii,8) = 0.d0
                ! flag as exiting via Outflow
                P(ii,10) = 1.d0
                goto 999

            end if
            ! otherwise we just leave it in the domain to reflect
            end if

            ! Find each particle's factional cell location
            Clocx = (P(ii,1) - float(Ploc(1))*dx)  / dx
            Clocy = (P(ii,2) - float(Ploc(2))*dy)  / dy

            Z = 0.d0
            do k = 1, Ploc(3)
                Z = Z + dz(k)
            end do
            Clocz = (P(ii,3) - Z) / dz(Ploc(3) + 1)

            ! Calculate local particle velocity using linear interpolation,
            ! converting darcy flux to average linear velocity

            Vpx = ((1.-Clocx)*Vx(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                  + Vx(Ploc(1)+2,Ploc(2)+1,Ploc(3)+1)*Clocx)   &
                  /(Porosity(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                  *Saturation(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Vpy = ((1.-Clocy)*Vy(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                    + Vy(Ploc(1)+1,Ploc(2)+2,Ploc(3)+1)*Clocy) &
                    /(Porosity(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                    *Saturation(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Vpz = ((1.-Clocz)*Vz(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                      + Vz(Ploc(1)+1,Ploc(2)+1,Ploc(3)+2)*Clocz)  &
                        /(Porosity(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                      *Saturation(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            ! calculate particle dt
            ! check each direction independently
            advdt = pfdt
            if (Vpx /= 0.) advdt(1) = abs(dtfrac*(dx/Vpx))
            if (Vpy /= 0.) advdt(2) = abs(dtfrac*(dy/Vpy))
            if (Vpz /= 0.) advdt(3) = dtfrac*(dz(Ploc(3)+1)/abs(Vpz))

            particledt = min(advdt(1), advdt(2), advdt(3), &
                             pfdt*dtfrac, delta_time-P(ii,4))

            ! calculate Flux in cell and compare it with the ET flux out of the cell
            if (EvapTrans(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) < 0.d0) then
            ! calculate ET flux volumetrically and compare to
            et_flux = abs(EvapTrans(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))*dx*dy*dz(Ploc(3)+1)

            ! compare total water removed from cell by ET with total water available in cell to arrive at a particle
            ! probability of being captured by roots
            ! water volume in cell
            water_vol = dx*dy*dz(Ploc(3)+1)*(Porosity(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                        *Saturation(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Zr = curand_uniform(h(ii))

            if (Zr < ((et_flux*particledt)/water_vol)) then   ! check if particle is 'captured' by the roots
            !  this section made atomic since it could inovlve a data race
            !  that is, each thread can only update the ET arrays one at a time

                temp = atomicAdd(ET_age(1), P(ii,4)*P(ii,6))

                temp = atomicAdd(ET_mass(1), P(ii,6))

                if (P(ii,7) == 1.) then
                temp = atomicAdd(ET_comp(1), P(ii,6))
                end if

                if (P(ii,7) == 2.) then
                temp = atomicAdd(ET_comp(2), P(ii,6))
                end if

                if (P(ii,7) == 3.) then
                temp = atomicAdd(ET_comp(3), P(ii,6))
                end if

                temp = atomicAdd(ET_np(1), idnint(lock))

                ! outputting spatially distributed ET information
                ! here it is a problem, probably have to be done after transfer.
                ! can keep it here but only for the area except overlap Zone
                ! temp = atomicAdd(C(6,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),lock)

                ! temp = atomicAdd(C(7,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,6)) ! particle mass added to ET

                ! temp = atomicAdd(C(8,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,4)*P(ii,6))  ! mass weighted age

                ! temp = atomicAdd(C(9,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,7)*P(ii,6))  ! mass weighted contribution

                ! now remove particle from domain
                P(ii,8) = 0.d0
                ! flag as exiting via ET
                P(ii,10) = 2.d0
                goto 999

            end if
            end if

            ! Advect particle to new location using Euler advection until next time
            P(ii,1) = P(ii,1) + particledt * Vpx
            P(ii,2) = P(ii,2) + particledt * Vpy
            P(ii,3) = P(ii,3) + particledt * Vpz
            P(ii,4) = P(ii,4) + particledt

            Ltemp = SQRT((particledt*Vpx)**2 + (particledt*Vpy)**2 + &
                         (particledt*Vpz)**2)

            ! Molecular Diffusion
            if (moldiff > 0.d0) then
            z1 = 2.d0*SQRT(3.d0)*(curand_uniform(h(ii))-0.5d0)
            z2 = 2.d0*SQRT(3.d0)*(curand_uniform(h(ii))-0.5d0)
            z3 = 2.d0*SQRT(3.d0)*(curand_uniform(h(ii))-0.5d0)

            P(ii,1) = P(ii,1) + z1 * SQRT(moldiff*2.d0*particledt)
            P(ii,2) = P(ii,2) + z2 * SQRT(moldiff*2.d0*particledt)
            P(ii,3) = P(ii,3) + z3 * SQRT(moldiff*2.d0*particledt)

            Ltemp = Ltemp + &
                         SQRT((z1*SQRT(moldiff*2.d0*particledt))**2 + &
                              (z2*SQRT(moldiff*2.d0*particledt))**2 + &
                              (z3*SQRT(moldiff*2.d0*particledt))**2)
            end if
            P(ii,11) = P(ii,11) + Ltemp
            ! placeholder for other interactions; potentially added later
            !
            ! place to track saturated / groundwater time if needed
            if(Saturation(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) == 1.) then
              P(ii,5) = P(ii,5) + particledt
              P(ii,12) = P(ii,12) + Ltemp
            end if

            if (nind > 0) then
              itemp=idnint(Ind(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
              if(itemp > 0 .and. itemp <= nind) then
                P(ii,12+itemp) = P(ii,12+itemp) + particledt
                P(ii,12+nind+itemp) = P(ii,12+nind+itemp) + Ltemp
              end  if
            end if

            if (reflect) then
            ! we can choose to reflect the particle or not if it is out of
            ! the whole modeling domain. g means the golbal boundary.
            ! I think just saving the global boundary in global memory.
            ! simple reflection boundary
                if (P(ii,3)          >= Zgmax) P(ii,3) = Zgmax- (P(ii,3) - Zgmax)
                if (P(ii,1) + ix1*dx >= Xgmax) P(ii,1) = Xgmax- (P(ii,1) + ix1*dx - Xgmax) - ix1*dx
                if (P(ii,2) + iy1*dy >= Ygmax) P(ii,2) = Ygmax- (P(ii,2) + iy1*dy - Ygmax) - iy1*dy
                if (P(ii,2) + iy1*dy <= Ygmin) P(ii,2) = Ygmin+ (Ygmin - (P(ii,2) + iy1*dy)) - iy1*dy
                if (P(ii,3)          <= Zgmin) P(ii,3) = Zgmin+ (Zgmin - P(ii,3))
                if (P(ii,1) + ix1*dx <= Xgmin) P(ii,1) = Xgmin+ (Xgmin - (P(ii,1) + ix1*dx)) - ix1*dx
            end if

            if ((P(ii,1) < Xmin).or.(P(ii,2) < Ymin).or.(P(ii,3) < Zmin).or. &
                (P(ii,1) >= Xmax).or.(P(ii,2) >= Ymax).or.(P(ii,3) >= Zmax)) then
                ! unavoidable particle loss
                ! flag particle as inactive
                P(ii,8) = 0.d0
                ! flag as exiting via loss
                P(ii,10) = 3.d0
                goto 999
            end if

        end do ! end of do-while loop for particle time to next time
        999 continue ! where we go if the particle is out of bounds

        ! concentration routine
        ! Find the "adjacent" "cell corresponding to the particle's location
        Ploc(1) = floor(P(ii,1) / dx)
        Ploc(2) = floor(P(ii,2) / dy)
        if(Ploc(1) >= nnx1 + buff) Ploc(1) = nnx1 + buff - 1
        if(Ploc(2) >= nny1 + buff) Ploc(2) = nny1 + buff - 1

        Z = 0.d0
        do k = 1, nz
            Z = Z + dz(k)
            if (Z >= P(ii,3)) then
                Ploc(3) = k - 1
                exit
            end if
        end do

        ! Zone/neighbor identification for cuda-aware transfer.
        ! since 0 and 1 are reserved for active and inactive particles,
        ! we add 10 to ranks. Otherwise, 0 and 1 are hard to be distinguished.
        ! keep an eye for ET particles
        P(ii,13+2*nind) = P(ii,8)
        if(Zone(Ploc(1)+1,Ploc(2)+1) /= rank) then
            if(P(ii,8) == 1. .or. (P(ii,8) == 0. .and. P(ii,10) == 2.)) &
            P(ii,13+2*nind) = Zone(Ploc(1)+1,Ploc(2)+1) + 10
        end if
        ! Hence, the active particles which will be sent to neighbors has been labeled

        ! Transfer local coordinates to global
        P(ii,1) = P(ii,1) + ix1*dx
        P(ii,2) = P(ii,2) + iy1*dy

    end if

 end subroutine particles_independent


 attributes(global) subroutine Update_C_Array(P,C,dx,dy,dz,nz,ix1,iy1, &
                                              nnx1,nny1,buff,mean_age, &
                                              mean_comp,total_mass,np_active)
    implicit none
    real(8),intent(in):: P(:,:),dz(:)
    real(8),intent(inout):: C(:,:,:,:)
    real(8),intent(inout):: mean_age(:),total_mass(:),mean_comp(:)
    integer,value:: nnx1,nny1,nz,ix1,iy1,buff,np_active
    real(8),value:: dx,dy
    integer:: Ploc(3), ii, k
    real(8):: lock, Z

    ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x
    lock = 1.d0

    if(ii < np_active) then
        ! Transfer global to local
        P(ii,1) = P(ii,1) - ix1*dx
        P(ii,2) = P(ii,2) - iy1*dy

        ! Find the "adjacent" "cell corresponding to the particle's location
        Ploc(1) = floor(P(ii,1) / dx)
        Ploc(2) = floor(P(ii,2) / dy)
        if(Ploc(1) >= nnx1 + buff) Ploc(1) = nnx1 + buff - 1
        if(Ploc(2) >= nny1 + buff) Ploc(2) = nny1 + buff - 1

        Z = 0.d0
        do k = 1, nz
            Z = Z + dz(k)
            if (Z >= P(ii,3)) then
                Ploc(3) = k - 1
                exit
            end if
        end do

        if(P(ii,8) == 0. .and. P(ii,10) == 2.) then
            temp = atomicAdd(C(6,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),lock)
            temp = atomicAdd(C(7,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,6))  ! particle mass added to ET
            temp = atomicAdd(C(8,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,4)*P(ii,6))  ! mass weighted age
            temp = atomicAdd(C(9,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,7)*P(ii,6))  ! mass weighted contribution
        end if

        temp = atomicAdd(C(1,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,8)*P(ii,11)*P(ii,6))
        temp = atomicAdd(C(2,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,8)*P(ii,4)*P(ii,6))
        temp = atomicAdd(C(4,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,8)*P(ii,5)*P(ii,6))
        temp = atomicAdd(C(3,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,8)*P(ii,6))
        temp = atomicAdd(C(5,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P(ii,8)*P(ii,12)*P(ii,6))
    !--------------------------------------
        ! increment mean age, composition and mass
        temp = atomicAdd(mean_age, P(ii,4)*P(ii,6))
        temp = atomicAdd(mean_comp, P(ii,7)*P(ii,6))
        temp = atomicAdd(total_mass, P(ii,6))
    !--------------------------------------
        P(ii,1) = P(ii,1) + ix1*dx
        P(ii,2) = P(ii,2) + iy1*dy
    end if

 end subroutine Update_C_Array

end module particle_loop

! send neighbors P(:,13+2*nind)
! connect receive
! update C array
! remove all inactive based on P(:,8)