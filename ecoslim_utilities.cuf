module utilities
    ! subroutine copy_grid
    ! subroutine combine_p_sum
    ! attributes(global) subroutine build_p_sum
    ! subroutine subzones_for_transfer
    ! subroutine receive_Zone_de

    use cudafor
    use variable_list, only: Xgmin, Xgmax, Ygmin, Ygmax
    use variable_list, only: buff, ppx, qqy, rank
    use variable_list, only: Zonet_old, Zonet_new

contains
    subroutine copy_grid(ix1,iy1,ix2,iy2,nnx1,nny1, &
                         nnx2,nny2,grid)
        implicit none
        integer:: ix1, iy1, ix2, iy2, nnx1, nny1, nnx2, nny2
        integer:: grid(:,:)

        if (rank /= ppx*qqy) then
            ix1  = grid(rank+1,1); nnx1 = grid(rank+1,3)
            iy1  = grid(rank+1,2); nny1 = grid(rank+1,4)

            ix2  = ix1 - buff; nnx2 = nnx1 + 2*buff
            iy2  = iy1 - buff; nny2 = nny1 + 2*buff

            if(ix1 == Xgmin) then
                ix2  = ix1
                nnx2 = nnx2 - buff
            endif
            if(ix1+nnx1 == Xgmax) nnx2 = nnx2 - buff

            if(iy1 == Ygmin) then
                iy2  = iy1
                nny2 = nny2 - buff
            endif
            if(iy1+nny1 == Ygmax) nny2 = nny2 - buff
        end if

    end subroutine copy_grid

    subroutine combine_p_sum()
        ! this part to utilities
        ! build p_sum on each rank
        call build_p_sum<<< ceiling(dble(np_active)/tPB),tPB >>>()

        ! send p_sum to the p_sum on rank of ppx*qqy
        ! now we could use send and recv while we latter can change to scatter/gather
        ! p_sum is the same name but the size is the whole domain on rank ppx*qqy
    end subroutine combine_p_sum

    attributes(global) subroutine build_p_sum()
        implicit none
        integer:: Ploc(3), ii, lock, temp
        ! p_sum doesn't need buffer zone

        ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        lock = 1

        if(ii < np_active) then
            P(ii,1) = P(ii,1) - ix1*dx
            P(ii,2) = P(ii,2) - iy1*dy

            Ploc(1) = floor(P(ii,1) / dx)
            Ploc(2) = floor(P(ii,2) / dy)

            temp = atomicAdd(p_sum(Ploc(1)+1,Ploc(2)+1),lock)

            P(ii,1) = P(ii,1) + ix1*dx
            P(ii,2) = P(ii,2) + iy1*dy
        endif

    end subroutine build_p_sum

    subroutine subzones_for_transfer()
        ! get Zone_de and Zones_new
        ! we use send and recv now, and will be changed to scatter and gather later
        implicit none
        integer:: ix1, iy1, ix2, iy2, nnx1, nny1, nnx2, nny2
        real(8)::

        if(rank == ppx*qqy) then
            do i = 0, ppx*qqy - 1
                ! build and send
                call MPI_ISEND(Zonet_new(:,:),N_send*(17+nind*2),MPI_DOUBLE_PRECISION,i,41,&
                MPI_COMM_WORLD,request4(ncount4),ierr)
            end do
        else
        endif
    end subroutine subzones_for_transfer

    subroutine receive_Zone_de(grid,rank)
        ! we use send and recv now, and will be changed to scatter and gather later
        use mpi
        implicit none
        integer:: ix1, iy1, nnx1, nny1
        integer:: ix1r, iy1r, nnx1r, nny1r
        integer:: ncount1, request1(ppx*qqy-1)
        integer:: ncount2, request2(ppx*qqy-1)
        integer:: rank, grid(:,:)
        integer:: i

        if(rank /= ppx*qqy) then
            ncount2 = rank
            ix1r = grid(rank+1,1);  iy1r = grid(rank+1,2)
            nnx1r = grid(rank+1,3); nny1r = grid(rank+1,4)
            call MPI_IRECV(Zone_de(1:nnx1r,1:nny1r),nnx1r*nny1r,MPI_INTEGER, &
            ppx*qqy,41,MPI_COMM_WORLD,request2(ncount2),ierr)
            ! Zone_de should be initialized as -1 before this call
        else
            ncount1 = 0
            do i = 0, ppx*qqy - 1
                ncount1 = ncount1 + 1
                 ix1 = grid(i+1,1);  iy1 = grid(i+1,2)
                nnx1 = grid(i+1,3); nny1 = grid(i+1,4)
                call MPI_ISEND(Zonet_new(ix1+1:ix1+nnx1,iy1+1:iy1+nny1),nnx1*nny1, &
                MPI_INTEGER,i,41,MPI_COMM_WORLD,request1(ncount1),ierr)
            end do
        endif
    end subroutine receive_Zone_de

end module utilities