module UpdateC_SortP
    use thrust
    use cudafor
    use compact_array
    use particle_loop
    use variable_list, only: N_exit, holes, P, P_exit
    use variable_list, only: P_de, d_isValid, d_indices
    ! use variable_list, only: mean_age_de, mean_comp_de, total_mass_de
    use variable_list, only: ix1, iy1, nind_c, tPB
    use variable_list, only: np_active, ranknum, filenum
    use variable_list, only: exit_time, C_time
    use variable_list, only: startEvent, stopEvent

contains
    subroutine Update_Sort()
        implicit none
        integer:: istat, temp

                #if _TIMING == 1
                istat = cudaEventRecord(startEvent,0)
                #endif

            call Update_C_Array<<< ceiling(dble(np_active)/tPB),tPB >>>( &
                ix1,iy1,np_active)

                #if _TIMING == 1
                istat = cudaEventRecord(stopEvent,0)
                istat = cudaEventSynchronize(stopEvent)
                istat = cudaEventElapsedTime(C_time,startEvent,stopEvent)
                #endif

            !-----------------------------------------
                #if _TIMING == 1
                istat = cudaEventRecord(startEvent,0)
                #endif

            ! then separate inactive particles
            call prepare_neighbor<<<ceiling(dble(np_active)/tPB),tPB>>>( &
                P_de(:,8),d_isValid,np_active,0)
            call thrustscan(d_isValid,np_active,d_indices)
            ! active and ET-inactive particles in overlap zone are sent
            ! out of domain, all outfolw-inactive, received ET-inactive are scanned here
            temp = d_indices(np_active)
            N_exit = np_active - temp

            if(N_exit > 0) then
                allocate(holes(N_exit),P_exit(N_exit,17+2*nind_c))
                ! P_exit has to be deallocated after the use in main
                call prepare_holes<<<ceiling(dble(np_active)/tPB),tPB>>>( &
                    holes,np_active)
                call select2exit<<<ceiling(dble(N_exit)/tPB),tPB>>>(&
                    holes,P_de,P_exit,N_exit)
                call compaction_inplace<<<ceiling(dble(np_active)/tPB),tPB>>>( &
                    holes,P_de,0,np_active)
                ! update the slots after np_active
                np_active = temp
                deallocate(holes,P_exit)
            end if

                #if _TIMING == 1
                istat = cudaEventRecord(stopEvent,0)
                istat = cudaEventSynchronize(stopEvent)
                istat = cudaEventElapsedTime(exit_time,startEvent,stopEvent)
                #endif

    end subroutine Update_Sort

end module UpdateC_SortP