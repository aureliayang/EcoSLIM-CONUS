module eco_updateC_sortP
    use thrust
    use cudafor
    use eco_compact_util
    use variable_list, only: N_exit, holes, P_exit
    use variable_list, only: P_de, C_de
    use variable_list, only: d_isValid, d_indices
    use variable_list, only: ix1_c, iy1_c, tPB
    use variable_list, only: np_active, nattri_c, nind_c
    use variable_list, only: exit_time, C_time
    use variable_list, only: startEvent, stopEvent
    use variable_list, only: mean_age_de,mean_comp_de,total_mass_de
    use variable_list, only: dx, dy, nz, dz_T
    use variable_list, only: Time_Next, kk, spinup

contains
    subroutine UpdateC_SortP()
        implicit none
        integer:: istat, temp
        integer:: i, j

                #if _TIMING == 1
                istat = cudaEventRecord(startEvent,0)
                #endif

            if(.not. spinup) &
            call Update_C_Array<<< ceiling(dble(np_active)/tPB),tPB >>>(np_active)

                #if _TIMING == 1
                istat = cudaEventRecord(stopEvent,0)
                istat = cudaEventSynchronize(stopEvent)
                istat = cudaEventElapsedTime(C_time,startEvent,stopEvent)
                #endif

            !-----------------------------------------
                #if _TIMING == 1
                istat = cudaEventRecord(startEvent,0)
                #endif

            ! then separate inactive particles
            call prepare_neighbor<<<ceiling(dble(np_active)/tPB),tPB>>>( &
                P_de(:,8),np_active,0)
            call thrustscan(d_isValid,np_active,d_indices)
            ! active and ET-inactive particles in overlap zone are sent
            ! out of domain, all outfolw-inactive, received ET-inactive are scanned here
            temp = d_indices(np_active)
            N_exit = np_active - temp

            if(N_exit > 0) then
                allocate(holes(N_exit),P_exit(N_exit,nattri_c))
                ! P_exit has to be deallocated after the use in main
                call prepare_holes<<<ceiling(dble(np_active)/tPB),tPB>>>( &
                    holes,np_active)
                call select2exit<<<ceiling(dble(N_exit)/tPB),tPB>>>(holes,P_exit,N_exit)

                ! add output to binary file here. P_exit is managed.
                ! not easy to write two parts of the attributes, so output all
                ! P_exit(:,13+2*nind_c) = Time_Next(kk)
                ! write(19) ((P_exit(i,j),j=1,nattri_c),i=1,N_exit)

                call compaction_inplace<<<ceiling(dble(np_active)/tPB),tPB>>>( &
                    holes,0,np_active)
                ! update the slots after np_active
                np_active = temp
                deallocate(holes,P_exit)
            end if

                #if _TIMING == 1
                istat = cudaEventRecord(stopEvent,0)
                istat = cudaEventSynchronize(stopEvent)
                istat = cudaEventElapsedTime(exit_time,startEvent,stopEvent)
                #endif

    end subroutine UpdateC_SortP

    attributes(global) subroutine Update_C_Array(np_active_m)

        implicit none
        integer,parameter:: tPB = 256
        integer,value:: np_active_m
        integer:: Ploc(3), ii, k, ii_s !5
        real(8):: Z, temp !6

        real(8),shared:: P_s(tPB,2)
        real(8):: P_l(4)

        ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        ii_s = threadIdx%x

        if(ii <= np_active_m) then

            P_s(ii_s,1:2) = P_de(ii,1:2)

            P_l(1) = P_de(ii,6)
            P_l(2) = P_l(1)*P_de(ii,8)
            P_l(3) = P_de(ii,4)
            P_l(4) = P_de(ii,7)

            ! Find the "adjacent" "cell corresponding to the particle's location
            Ploc(1) = floor(P_s(ii_s,1) / dx)
            Ploc(2) = floor(P_s(ii_s,2) / dy)

            Z = 0.d0
            do k = 1, nz
                Z = Z + dz_T(k)
                if (Z >= P_de(ii,3)) then
                    Ploc(3) = k - 1
                    exit
                end if
            end do
            Z = 1.0

            Ploc(1) = Ploc(1) + 1
            Ploc(2) = Ploc(2) + 1
            Ploc(3) = Ploc(3) + 1

            if(P_l(2) == 0. .and. P_de(ii,10) == 2.) then
                temp = atomicAdd(C_de(6,Ploc(1),Ploc(2),Ploc(3)),Z)
                temp = atomicAdd(C_de(7,Ploc(1),Ploc(2),Ploc(3)),P_l(1))  ! particle mass added to ET
                temp = atomicAdd(C_de(8,Ploc(1),Ploc(2),Ploc(3)),P_l(3)*P_l(1))  ! mass weighted age
                temp = atomicAdd(C_de(9,Ploc(1),Ploc(2),Ploc(3)),P_l(4)*P_l(1))  ! mass weighted contribution
            end if

            temp = atomicAdd(C_de(1,Ploc(1),Ploc(2),Ploc(3)),P_l(2)*P_de(ii,11))
            temp = atomicAdd(C_de(2,Ploc(1),Ploc(2),Ploc(3)),P_l(2)*P_l(3))
            temp = atomicAdd(C_de(4,Ploc(1),Ploc(2),Ploc(3)),P_l(2)*P_de(ii,5))
            temp = atomicAdd(C_de(3,Ploc(1),Ploc(2),Ploc(3)),P_l(2))
            temp = atomicAdd(C_de(5,Ploc(1),Ploc(2),Ploc(3)),P_l(2)*P_de(ii,12))

            !--------------------------------------
            ! increment mean age, composition and mass
            temp = atomicAdd(mean_age_de,   P_l(2)*P_l(3))
            temp = atomicAdd(mean_comp_de,  P_l(2)*P_l(4))
            temp = atomicAdd(total_mass_de, P_l(2))

        end if

    end subroutine Update_C_Array

end module eco_updateC_sortP