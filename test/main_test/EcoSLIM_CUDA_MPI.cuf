! Last Change:  2020-11-12 17:43:44
!--------------------------------------------------------------------
! **EcoSLIM** is a Lagrangian, particle-tracking that simulates advective
! and diffusive movement of water parcels.  This code can be used to
! simulate age, diagnosing travel times, source water composition and
! flowpaths.  It integrates seamlessly with **ParFlow-CLM**.
!
! Developed by: Reed Maxwell-August 2016 (rmaxwell@mines.edu)
!
! Contributors: Laura Condon (lecondon@email.arizona.edu)
!               Mohammad Danesh-Yazdi (danesh@sharif.edu)
!               Lindsay Bearup (lbearup@usbr.gov)
!
! released under GNU LPGL, see LICENSE file for details
!--------------------------------------------------------------------
! 06/26/2021 GPU version, Chen Yang
!--------------------------------------------------------------------
program EcoSLIM
use mpi
use cudafor
use mrand
use thrust
use utilities
use particle_loop
use mpiDeviceUtil
use variable_list
! use hdf5_file_read
! use hdf5_file_write
use subdomain_bound
use create_subdomain
use add_particles
use compact_array
! use exchange_zone
! use exchange_particles

implicit none
integer(8),pinned,allocatable:: p_num_cpu(:,:)
!--------------------------------------------------------------------
    call MPI_INIT(ierr)
    call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr)
    call MPI_COMM_SIZE(MPI_COMM_WORLD, t_rank, ierr)
    ! t_tank = ppx*qqy + 1. ppx*qqy is the total number of subdomains,
    ! and is also be the index number of manager rank. rank number of workers is 0 to ppx*qqy.
    ! one more rank for DDC, so the number of subdomains is t_rank-1
    ! be careful about this rank when doing everything

    ! call open_hdf5_interface()
!--------------------------------------------------------------------
    ! Get and set unique device
    call assignDevice(deviceID)
    call MPI_GET_PROCESSOR_NAME(hostname, namelength, ierr)
    write(message,"('[',i2.2 ,'] host: ', a, ', device: ', i2.2, a)") &
    rank, trim(hostname), deviceID, new_line(' ')
    offset = len(trim(message))*rank

    call MPI_FILE_OPEN(MPI_COMM_WORLD, 'EcoSLIM_Device_Utility.txt', &
    MPI_MODE_WRONLY + MPI_MODE_CREATE, MPI_INFO_NULL, fh0, ierr)
    call MPI_FILE_SEEK(fh0,offset,MPI_SEEK_SET,ierr)
    call MPI_FILE_WRITE(fh0,message,len(trim(message)),MPI_CHARACTER, &
        MPI_STATUS_IGNORE, ierr)
    call MPI_FILE_CLOSE(fh0, ierr)

!--------------------------------------------------------------------
    ! how to do timing is also a new question when asyn later.
    ! Set up timing
    Total_time1 = 0.d0
    Total_time2 = 0.d0
    t1 = 0.d0
    t2 = 0.d0
    IO_time_read = 0.d0
    IO_time_write = 0.d0
    parallel_time = 0.d0
    sort_time = 0.d0

!--------------------------------------------------------------------
    ! Read inputs, set up domain, write the log file
    ! no need to exclude the manager rank since only several scalar variables are read
    ! and these scalar variables have already been on the mananger rank due to declaration
    ! open SLIM input .txt file
    open (10,file='slimin.txt')

    ! read SLIM run name
    read(10,*) runname

    ! read ParFlow run name
    read(10,*) pname

    ! read DEM file name
    read(10,*) DEMname

    if(rank == 0) then
        ! open/create/write the output log.txt file. If doesn't exist, it's created.
        open(11,file=trim(runname)//'_log.txt')
        write(11,*) '### EcoSLIM Log File'
        write(11,*)
        write(11,*) 'run name:',trim(runname)
        write(11,*)
        write(11,*) 'ParFlow run name:',trim(pname)
        write(11,*)
        if (DEMname /= '') then
            write(11,*) 'ParFlow DEM name:',trim(DEMname)
        else
            write(11,*) 'Not reading ParFlow DEM'
        end if
        write(11,*)
    endif ! rank = 0, write logfile through channel 11

    ! read domain number of cells and number of particles to be injected
    read(10,*) nx
    read(10,*) ny
    read(10,*) nz
    read(10,*) nCLMsoil
    read(10,*) ppx
    read(10,*) qqy
    ! read in number of particles for IC (if np_ic = -1 then restart from a file)
    read(10,*) np_ic

    ! read in the number of particles total
    read(10,*) np

    if(rank == 0) then
        ! check to make sure we don't assign more particles for IC than we have allocated
        ! in total
        if (np_ic > np) then
        write(11,*) 'warning NP_IC greater than IC'
        np = np_ic
        end if
        ! write nx, ny, nz, and np in the log file
        write(11,*) 'Grid information'
        write(11,*) 'nx:',nx
        write(11,*) 'ny:',ny
        write(11,*) 'nz:',nz
        write(11,*)
        write(11,*) 'Particle IC Information'
        write(11,*) 'np IC:',np_ic
        if (np_ic == -1) &
        write(11,*) 'Reading particle restart file:',trim(runname)//'_particle_restart.bin'
        write(11,*) 'np:',np
    endif ! rank=0

    ! nCLMsoil = 10 ! number of CLM soil layers over the root zone !this doesn't matter
    nzclm = 13 + nCLMsoil ! CLM output is 13+nCLMsoil layers for different variables not domain NZ,
                          ! e.g. 23 for 10 soil layers (default) and 17 for 4 soil layers (Noah soil
                          ! layer setup)
    n_constituents = 9

    allocate(dz(nz),dz2(nz),dz_de(nz))
    ! have to do this here since the following read of dz

    ! read dx, dy as scalars
    read(10,*) dx
    read(10,*) dy
    ! read dz as an array
    read(10,*) dz(1:nz)
    dz2 = dz
    ! read in (constant for now) ParFlow dt
    read(10,*) pfdt
    ! read in parflow start and stop times
    read(10,*) pft1
    read(10,*) pft2
    read(10,*) tout1
    read(10,*) n_cycle
    read(10,*) add_f

    pfnt = n_cycle*(pft2-pft1+1)
    outkk = tout1 + 1

    ! IO control, each value is a timestep interval, e.g. 1= every timestep, 2=every other, 0 = no writing
    read(10,*) ipwrite        ! controls an ASCII, .3D particle file not recommended due to poor performance
    read(10,*) ibinpntswrite  !  controls VTK, binary output of particle locations and attributes
    read(10,*) etwrite        !  controls ASCII ET output
    read(10,*) icwrite        ! controls VTK, binary grid based output where particle masses, concentrations,
                              ! ages are mapped to a grid and written every N timesteps

    ! allocate and assign timesteps
    ! this can be a scalar and update every timestep
    allocate(Time_Next(pfnt))
    Time_Next=0.d0
    do kk = outkk, pfnt
        Time_Next(kk) = float(kk)*pfdt
    end do
    Time_first = float(outkk-1)*pfdt

    ! read in velocity multiplier
    read(10,*) V_mult
    ! do we read in clm evap trans?
    read(10,*) clmtrans
    ! do we read in clm output file?
    read(10,*) clmfile
    ! read in IC number of particles for flux
    read(10,*) iflux_p_res
    ! read in density h2o
    read(10,*) denh2o
    ! read in diffusivity
    ! moldiff = (1.15e-9)*3600.d0
    read(10,*) moldiff
    ! fraction of dx/Vx
    read(10,*) dtfrac

    if(rank == 0) then
        ! wite out log file
        write(11,*)
        write(11,*) 'Grid Dimensions'
        write(11,'(" dx:",e12.5)') dx
        write(11,'(" dy:",e12.5)') dy
        write(11,'(" dz:",*(e12.5,", "))') dz(1:nz)
        write(11,*)
        write(11,*) 'Timestepping Information'
        write(11,'(" ParFlow delta-T, pfdt:",e12.5)') pfdt
        write(11,'(" ParFlow timesteps, pfnt:",i12)') pfnt
        write(11,'(" ParFlow start step, pft1:",i12)') pft1
        write(11,'(" ParFlow end step, pft2:",i12)') pft2
        write(11,'(" Output step start:",i12)') outkk
        write(11,'(" Time loops, cycles, n_cycle:",i12)') n_cycle
        write(11,'(" Total time steps:",i12)') pfnt

        write(11,*)
        write(11,*) 'V mult: ',V_mult,' for forward/backward particle tracking'
        write(11,*) 'CLM Trans: ',clmtrans,' adds / removes particles based on LSM fluxes'
        write(11,*)
        write(11,*) 'Physical Constants'
        write(11,*) 'denh2o: ',denh2o,' M/L^3'
        write(11,*) 'Molecular Diffusivity: ',moldiff,' '
        !write(11,*) 'Fractionation: ',Efract,' '
        write(11,*)
        write(11,*) 'Numerical Stability Information'
        write(11,'(" dtfrac: ",e12.5," fraction of dx/Vx")') dtfrac
    endif

    read(10,*) nind
    read(10,*) Indname
    if(rank == 0) then
        write(11,*)
        write(11,*) 'Indicator File'
        write(11,*) nind, 'Indicators'
    endif

    ! end of SLIM input
    close(10)
!--------------------------------------------------------------------
    print *, 'Read ok1'
    ! build new communicators for communication
    call MPI_COMM_GROUP(MPI_COMM_WORLD, world_group, ierr)
    manage_ranks = ppx*qqy ! only one rank used to manage
    call MPI_GROUP_EXCL(world_group, 1, manage_ranks, work_group, ierr)
    call MPI_GROUP_INCL(world_group, 1, manage_ranks, manage_group, ierr)
    call MPI_COMM_CREATE(MPI_COMM_WORLD, work_group, work_comm, ierr)
    call MPI_COMM_CREATE(MPI_COMM_WORLD, manage_group, manage_comm, ierr)
!--------------------------------------------------------------------
    ! debug
    write(ranknum,'(i5.5)') rank
    open(10,file='Read_check.'//trim(adjustl(ranknum)))
        write(10,*) runname
        write(10,*) pname
        write(10,*) DEMname
        write(10,*) nx
        write(10,*) ny
        write(10,*) nz
        write(10,*) nCLMsoil
        write(10,*) ppx
        write(10,*) qqy
        write(10,*) np_ic
        write(10,*) np
        write(10,*) dx
        write(10,*) dy
        write(10,*) dz(1:nz)
        write(10,*) pfdt
        write(10,*) pft1
        write(10,*) pft2
        write(10,*) tout1
        write(10,*) n_cycle
        write(10,*) add_f
        write(10,*) ipwrite        ! controls an ASCII, .3D particle file not recommended due to poor performance
        write(10,*) ibinpntswrite  ! controls VTK, binary output of particle locations and attributes
        write(10,*) etwrite        ! controls ASCII ET output
        write(10,*) icwrite        ! controls VTK, binary grid based output where particle masses, concentrations,
        write(10,*) V_mult
        write(10,*) clmtrans
        write(10,*) clmfile
        write(10,*) iflux_p_res
        write(10,*) denh2o
        write(10,*) moldiff
        write(10,*) dtfrac
        write(10,*) nind
        write(10,*) Indname
    close(10)

!--------------------------------------------------------------------
    if(rank == ppx*qqy) then

        allocate(grid(ppx*qqy,4),grid_old(ppx*qqy,4))
        allocate(Zonet_old(-buff+1:nx+buff,-buff+1:ny+buff))
        allocate(Zonet_new(-buff+1:nx+buff,-buff+1:ny+buff))
        allocate(p_num(nx,ny),c_sum(max(nx,ny)),d_indices(np))
        grid = 0; Zonet_new = -1; Zonet_new(1:nx,1:ny) = 0
        ! allocate(p_num_cpu(nx,ny))
        ! p_num_cpu = 1_8 ! check such an initialization. Checked and should be right.
        p_num = 1
        ! p_num_cpu = 0
        ! p_num_cpu = p_num
        ! write(*,'(8(9(i3,1x),/))') ((p_num_cpu(i,j),i=1,nx),j=1,ny)
        ! write(*,'(10(11(i3,1x),/))') ((Zonet_old(i,j),i=-buff+1,nx+buff),j=-buff+1,ny+buff)
        ! write(*,'(10(11(i3,1x),/))') ((Zonet_new(i,j),i=-buff+1,nx+buff),j=-buff+1,ny+buff)
        ! write(*,'(4(4(i3,1x),/))') ((grid(i,j),i=1,ppx*qqy),j=1,4)

    end if   ! set the manager


    9090 continue

    ! call close_hdf5_interface()
    call MPI_FINALIZE(ierr)

end program EcoSLIM

