module create_subdomain
    ! subroutine gridinfo
    ! attributes(global) subroutine column_sum
    ! attributes(global) subroutine build_tree
    !--------------------------------------------
    ! this module is used to decompose the modeling domain based on
    ! p_num. For init, p_num=1, so the domain will be evenly decomposed.

    use cudafor
    use thrust

    use variable_list, only: p_num, c_sum
    use variable_list, only: d_indices
    use variable_list, only: nx, ny, ppx, qqy, tPB, rank, t_rank !,ierr, buff
    use variable_list, only: grid_old, grid
    ! grid is on each rank while grid_old is only on ppx*qqy
    use variable_list, only: Zonet_old, Zonet_new

contains
    subroutine gridinfo()
        ! this kernel only happens on manager
        ! 1 0 0 0 0 0 0 0  n=8  nd=4 j do 1
        ! 1 0 0 0 1 0 0 0  n=4  nd=2 j do 2
        ! 1 0 1 0 1 0 1 0  n=2  nd=1 j do 4 after this, it is done
        ! 1 1 1 1 1 1 1 1

        ! n is the interval between father nodes
        ! nd is the interval between the new child node and its father node

        use mpi
        implicit none
        integer:: i, j, dir, nlev, n !,k,ii,jj
        integer:: max_dim,ndim1,ndim2 !, ierr
        !integer(8):: c_sum_cpu(9)
        !integer:: indices_cpu(9)

        !if (rank == ppx*qqy) then ! at least, this if condition doesn't conflict

            grid_old  = grid
            Zonet_old = Zonet_new
            grid = 0   ! this is legal
            grid(1,1) = 0
            grid(1,2) = 0
            grid(1,3) = nx
            grid(1,4) = ny
            Zonet_new = -1
            Zonet_new(1:nx,1:ny) = 0

            dir = 1
            if(qqy > ppx) dir = -1
            ! dir = 1, split starts from x direction while -1 y direction
            ! however, you have to think about much more times split in one direction
            ! such as, you just split once across y axis while 5 times across x direction
            nlev = idnint(dlog(dble(ppx*qqy))/dlog(2.d0))
            n = ppx*qqy

            do i = 1, nlev
                do j = 1, ppx*qqy, n ! which father node
                    if (dir == 1) then
                        ndim1 = grid(j,3)
                        ndim2 = grid(j,4)
                        call column_sum<<<ceiling(dble(ndim1)/tPB),tPB>>>(j,dir)
                        call thrustscan(c_sum,ndim1,d_indices) ! prefix-sum of c_sum
                        max_dim = max(ppx*qqy,ndim1*ndim2)
                        !write(*,'(4(4(i3,1x),/))') grid_old,rank
                        call build_tree<<<ceiling(dble(max_dim)/tPB),tPB>>>(n,dir,j,rank)
                        !grid_old = grid
                        !write(*,'(4(4(i3,1x),/))') grid_old,rank
                        !Zonet_old = Zonet_new
                        !write(*,'(7(22(i3,1x),/))') ((Zonet_old(ii,jj),ii=-buff+1,nx+buff),jj=-buff+1,ny+buff)
                    else
                        ndim1 = grid(j,3)
                        ndim2 = grid(j,4)
                        call column_sum<<<ceiling(dble(ndim2)/tPB),tPB>>>(j,dir)
                        call thrustscan(c_sum,ndim2,d_indices)
                        max_dim = max(ppx*qqy,ndim1*ndim2)
                        !write(*,'(4(4(i3,1x),/))') grid,rank
                        call build_tree<<<ceiling(dble(max_dim)/tPB),tPB>>>(n,dir,j,rank)
                        !write(*,'(4(4(i3,1x),/))') grid,rank
                        !Zonet_old = Zonet_new
                        !write(*,'(7(22(i3,1x),/))') ((Zonet_old(ii,jj),ii=-buff+1,nx+buff),jj=-buff+1,ny+buff)
                    endif

                     !do k = 0, t_rank-1
                     !    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
                     !    if(k == rank) then
                     !        c_sum_cpu = c_sum
                     !        write(*,'(i3,a,9(i3,1x))') rank,'c_sum',c_sum_cpu
                     !        indices_cpu = d_indices(1:9)
                     !        write(*,'(a,9(i3,1x))') 'd_indices',indices_cpu
                     !        write(*,'(4(4(i3,1x),/))') grid
                     !    endif
                     !enddo

                end do
                if(min(ppx,qqy) > 1) dir = -dir ! if means at least split once (i.e., 2)
                !!! for this subroutine, you should think about if split in one direction
                !!! is much more than the other direction???
                n = n/2
            end do
        !endif

    end subroutine gridinfo

    attributes(global) subroutine column_sum(j,dir)
        implicit none
        integer,value:: j, dir
        integer:: ii, tempx0, tempy0, tempnx, tempny

        ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

        tempx0 = grid(j,1)
        tempy0 = grid(j,2)
        tempnx = grid(j,3)
        tempny = grid(j,4)

        if (dir == 1) then
            if(ii >= 1 .and. ii <= tempnx) then
                c_sum(ii) = sum(p_num(ii+tempx0,tempy0+1:tempy0+tempny))
            endif
        else
            if(ii >= 1 .and. ii <= tempny) then
                c_sum(ii) = sum(p_num(tempx0+1:tempx0+tempnx,ii+tempy0))
            endif
        end if

    end subroutine column_sum

    attributes(grid_global) subroutine build_tree(n,dir,j,rank)

        implicit none
        integer,value:: n, dir, j, rank ! j is the current father node
        integer:: ii, nd, tempx0, tempy0, tempnx, tempny
        integer:: ik, jk, length

        ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

        tempx0 = grid(j,1)
        tempy0 = grid(j,2)
        tempnx = grid(j,3)
        tempny = grid(j,4)

        nd = n/2
        ! n is the interval between father nodes
        ! nd is the interval between the new child node and its father node

        if (dir == 1) then
            if(ii > 1 .and. ii < tempnx) then ! reasonable but not safe
                if(d_indices(ii) <= d_indices(tempnx)/2 .and. &
                d_indices(ii+1) > d_indices(tempnx)/2) then
                    grid(j+nd,1) = tempx0 + ii
                    grid(j+nd,2) = grid(j,2)
                    grid(j+nd,3) = tempnx - ii
                    grid(j+nd,4) = grid(j,4)
                    grid(j,3) = ii
                    !print *, ii,rank
                endif
            endif
        else
            if(ii > 1 .and. ii < tempny) then
                if(d_indices(ii) <= d_indices(tempny)/2 .and. &
                d_indices(ii+1) > d_indices(tempny)/2) then
                    grid(j+nd,1) = grid(j,1)
                    grid(j+nd,2) = tempy0 + ii
                    grid(j+nd,3) = grid(j,3)
                    grid(j+nd,4) = tempny - ii
                    grid(j,4) = ii
                    !print *, ii,rank
                endif
            endif
        end if

        call syncthreads()
        length = grid(j+nd,3)*grid(j+nd,4)
        !print *, length,rank,grid(j+nd,3),grid(j+nd,4)
        ! this is the total length of zone array when it was transformed to 1D
        ! so the threads are more than this number. Probably we can split this
        ! part to a new kernel.

        if(ii <= length) then
            if(mod(ii,grid(j+nd,3)) == 0) then
                jk = grid(j+nd,2) + ii/grid(j+nd,3)
                ik = grid(j+nd,1) + grid(j+nd,3)
            else
                jk = grid(j+nd,2) + ii/grid(j+nd,3) + 1
                ik = grid(j+nd,1) + mod(ii,grid(j+nd,3))
            end if
            Zonet_new(ik,jk) = j + nd - 1
            !print *, ik,jk,rank,j + nd - 1,Zonet_new(ik,jk)
        end if
        ! buffer zone has been set as -1
        ! in this operation, buffer is not considered while buffer is considered
        ! in some other subroutines.

    end subroutine build_tree

end module create_subdomain

