module create_subdomain
    ! subroutine gridinfo
    ! attributes(global) subroutine column_sum
    ! attributes(global) subroutine build_tree
    !--------------------------------------------
    ! this module is used to decompose the modeling domain based on
    ! p_num. For init, p_num=1, so the domain will be evenly decomposed.

    use cudafor
    use thrust

    use variable_list, only: p_num, c_sum
    use variable_list, only: d_indices
    use variable_list, only: nx, ny, ppx, qqy, tPB, rank
    use variable_list, only: grid_old, grid
    ! grid is on each rank while grid_old is only on ppx*qqy
    use variable_list, only: Zonet_old, Zonet_new

contains
    subroutine gridinfo()
        ! this kernel only happens on manager
        ! 1 0 0 0 0 0 0 0  n=8  nd=4 j do 1
        ! 1 0 0 0 1 0 0 0  n=4  nd=2 j do 2
        ! 1 0 1 0 1 0 1 0  n=2  nd=1 j do 4 after this, it is done
        ! 1 1 1 1 1 1 1 1

        ! n is the interval between father nodes
        ! nd is the interval between the new child node and its father node

        use mpi
        implicit none
        integer:: i, j, dir, nlev, n
        integer:: max_dim, ierr
        integer:: c_sum_cpu(9),indices_cpu(9)

        if (rank == ppx*qqy) then ! at least, this if condition doesn't conflict

            grid_old  = grid
            Zonet_old = Zonet_new
            grid = 0   ! this is legal
            grid(1,1) = 0
            grid(1,2) = 0
            grid(1,3) = nx
            grid(1,4) = ny
            Zonet_new = -1
            Zonet_new(1:nx,1:ny) = 0
            write(*,'(4(4(i3,1x),/))') grid

            dir = 1
            if(qqy > ppx) dir = -1
            ! dir = 1, split starts from x direction while -1 y direction
            ! however, you have to think about much more times split in one direction
            ! such as, you just split once across y axis while 5 times across x direction
            nlev = idnint(dlog(dble(ppx*qqy))/dlog(2.d0))
            n = ppx*qqy

            do i = 1, nlev
                do j = 1, ppx*qqy, n ! which father node
                    if (dir == 1) then
                        call column_sum<<<ceiling(dble(grid(j,3))/tPB),tPB>>>(j,dir)
                        call thrustscan(c_sum,grid(j,3),d_indices) ! prefix-sum of c_sum
                        max_dim = max(ppx*qqy,grid(j,3)*grid(j,4))
                        call build_tree<<<ceiling(dble(max_dim)/tPB),tPB>>>(n,dir,j)
                    else
                        call column_sum<<<ceiling(dble(grid(j,4))/tPB),tPB>>>(j,dir)
                        call thrustscan(c_sum,grid(j,4),d_indices)
                        max_dim = max(ppx*qqy,grid(j,3)*grid(j,4))
                        call build_tree<<<ceiling(dble(max_dim)/tPB),tPB>>>(n,dir,j)
                    endif
                end do
                if(min(ppx,qqy) > 1) dir = -dir ! if means at least split once (i.e., 2)
                !!! for this subroutine, you should think about if split in one direction
                !!! is much more than the other direction???
                n = n/2
                c_sum_cpu = c_sum
                write(*,'(9(i3,1x))') c_sum_cpu
                indices_cpu = d_indices(1:9)
                write(*,'(9(i3,1x))') indices_cpu
                write(*,'(4(4(i3,1x),/))') grid
            end do
        endif

        ! bcast grid array and then copy to ix1n etc. on workers
        call MPI_BCAST(grid,ppx*qqy*4,MPI_INTEGER,ppx*qqy,MPI_COMM_WORLD,ierr)

    end subroutine gridinfo

    attributes(global) subroutine column_sum(j,dir)
        implicit none
        integer,value:: j, dir
        integer:: ii, tempx0, tempy0, tempnx, tempny

        ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

        tempx0 = grid(j,1)
        tempy0 = grid(j,2)
        tempnx = grid(j,3)
        tempny = grid(j,4)

        if (dir == 1) then
            if(ii >= 1 .and. ii <= tempnx) then
                c_sum(ii) = sum(p_num(ii+tempx0,tempy0+1:tempy0+tempny))
            endif
        else
            if(ii >= 1 .and. ii <= tempny) then
                c_sum(ii) = sum(p_num(tempx0+1:tempx0+tempnx,ii+tempy0))
            endif
        end if

    end subroutine column_sum

    attributes(global) subroutine build_tree(n,dir,j)

        implicit none
        integer,value:: n, dir, j ! j is the current father node
        integer:: ii, nd, tempx0, tempy0, tempnx, tempny
        integer:: ik, jk, length

        ii = (blockIdx%x - 1) * blockDim%x + threadIdx%x

        tempx0 = grid(j,1)
        tempy0 = grid(j,2)
        tempnx = grid(j,3)
        tempny = grid(j,4)

        nd = n/2
        ! n is the interval between father nodes
        ! nd is the interval between the new child node and its father node

        if (dir == 1) then
            if(ii > 1 .and. ii < tempnx) then ! reasonable but not safe
                if(d_indices(ii) <= d_indices(tempnx)/2 .and. &
                d_indices(ii+1) > d_indices(tempnx)/2) then
                    grid(j+nd,1) = tempx0 + ii
                    grid(j+nd,2) = grid(j,2)
                    grid(j+nd,3) = tempnx - ii
                    grid(j+nd,4) = grid(j,4)
                    grid(j,3) = ii
                endif
            endif
        else
            if(ii > 1 .and. ii < tempny) then
                if(d_indices(ii) <= d_indices(tempny)/2 .and. &
                d_indices(ii+1) > d_indices(tempny)/2) then
                    grid(j+nd,1) = grid(j,1)
                    grid(j+nd,2) = tempy0 + ii
                    grid(j+nd,3) = grid(j,3)
                    grid(j+nd,4) = tempny - ii
                    grid(j,4) = ii
                endif
            endif
        end if

        length = grid(j+nd,3)*grid(j+nd,4)
        ! this is the total length of zone array when it was transformed to 1D
        ! so the threads are more than this number. Probably we can split this
        ! part to a new kernel.

        if(ii <= length) then
            if(mod(ii,grid(j+nd,3)) == 0) then
                jk = grid(j+nd,2) + ii/grid(j+nd,3)
                ik = grid(j+nd,1) + grid(j+nd,3)
            else
                jk = grid(j+nd,2) + ii/grid(j+nd,3) + 1
                ik = grid(j+nd,1) + mod(ii,grid(j+nd,3))
            end if
            Zonet_new(ik,jk) = j + nd - 1
        end if
        ! buffer zone has been set as -1
        ! in this operation, buffer is not considered while buffer is considered
        ! in some other subroutines.

    end subroutine build_tree

end module create_subdomain

